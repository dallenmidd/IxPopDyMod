---
title: "benchmarking"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## get_temp
When profiling `run()` (see `profile1.Rprofvis`), it was evident that most of the model run time was in `update_delay_arr()` and `gen_trans_matrix()`. Following the hierarchy of calls, both of these functions call `get_transition_val()` which calls `get_pred()` which calls `get_temp()` and/or `get_host_den()`. Across the board in all these functions, the pipe operator was a top (2nd if not 1st) use of time and memory. I was really surprised to see this, but I found a few threads like this [one](https://stackoverflow.com/questions/35933272/why-is-using-dplyr-pipe-slower-than-an-equivalent-non-pipe-expression-for/35935105), which cites "the oft-quoted recommendation that pipes are okay on the command line where your brain thinks in chains, but not in functions that might be time-critical."

Many functions in `core_functions.R` are called MANY times, and do little work on each iteration. For example, I think `get_pred()` gets called twice for each transition at each time step... So the takeaway is that speeding up these functions could lead to significant performance improvements, hopefully without compromising readability too much. Based on the recommendation above, this will likely involve removing pipes from functions that are called many times.

I'll start with `get_temp()`, because it's small and easy to refactor. 

```{r get_temp}
library(tidyverse)
library(bench)

weather <- tibble(tmean = runif(100, 10, 20), j_day = 1:100)


# original function
get_temp <- function(time) {
  weather %>%
    filter(j_day %in% time) %>%
    pull(tmean)
}

get_temp2 <- function(time) {
  pull(filter(weather, j_day %in% time), tmean)
}

get_temp3 <- function(time) {
  filter(weather, j_day %in% time)$tmean
}

get_temp4 <- function(time) {
  weather[weather$j_day %in% time, ]$tmean
}

get_temp5 <- function(time) {
  weather[which(weather$j_day %in% time), ]$tmean
}

# temperature for days 1 to 10
t <- seq(1, 10)

bnch <- mark(get_temp(t), get_temp2(t), get_temp3(t), get_temp4(t), get_temp5(t))
bnch

```

### takeaway
`get_temp5()` appears to be the fastest (over 30x faster than original) and use least memory. A similar optimization should also work for `get_host_den()`.

```{r get_host_den}

steps <- 100

# sample host community data
host_comm <- tibble(
  j_day = rep(1:steps, each=2),
  host_spp = rep(c('rodent', 'deer'), steps),
  host_den = rep(c(200, 20), steps)) %>% 
  arrange(j_day, host_spp)

# original 
get_host_den <- function(time) {
  host_comm %>%
    filter(j_day %in% time) %>%
    pull(host_den)
}

get_host_den2 <- function(time) {
  host_comm[which(host_comm$j_day %in% time), ]$host_den
}

bnch <- mark(get_host_den(t), get_host_den2(t))
bnch

```

As expected, the same approach, `get_host_den2()`, is also much faster than the original.

## whole model implications

Now, the question is, how do these changes impact the total runtime of the model. I ran the model with the Ogden inputs for 500 steps, before and after switching to the faster versions of `get_host_den()` and `get_temp()`. Total runtime went down from about 60 seconds to 48 seconds. Memory usage was pretty much the same. Also, the relative time spent in the two updated functions decreased a lot, so I'm pretty confident this had the desired effect. 

## get_transition_val()


``` {r get_transition_val}
library(tidyverse)
library(bench)
source('../user_defined_functions.R')
source('../core_functions.R')
steps <- 300
tick_transitions <- read_csv('../inputs/tick_transitions.csv')
transition_row <- tick_transitions[34,] # pick a transition row that involves host community
life_stages <- tick_transitions %>% pull(from) %>% unique()
tick_params <- read_csv('../inputs/tick_parameters.csv') %>% arrange(host_spp)
host_comm <- tibble(
  j_day = rep(1:steps, each=3), 
  host_spp = rep(c('mouse', 'squirrel', 'deer'), steps), 
  host_den = rep(c(100, 8, 8), steps)) %>%
  # host_den = runif(steps * 3, .75, 1.25) * rep(c(40, 8, 0.25), steps)) %>% 
  arrange(j_day, host_spp)
n_host_spp <- host_comm %>% pull(host_spp) %>% unique() %>% length()
time <- 1
N <- matrix(nrow = length(life_stages), ncol = steps, data = 0)
N[,1] <- 10 
rownames(N) <- life_stages
N_developing <- matrix(nrow = length(life_stages), ncol = steps, data = 0)
rownames(N) <- life_stages

get_transition_val <- function(time, transition_row, N, N_developing, parameters = tick_params) {
  
  f <- transition_row[['transition_fun']] %>% get()
  
  params <- parameters %>% 
    filter(str_detect(transition_row[['from']], from), str_detect(transition_row[['to']], to)) %>%
    pull(param_value)
  
  names(params) <- parameters %>%
    filter(str_detect(transition_row[['from']], from), str_detect(transition_row[['to']], to)) %>%
    pull(param_name)
  
  params <- tapply(unname(params), rep(names(params), lengths(params)), FUN = c)
  
  pred1 <- get_pred(time, transition_row[['pred1']], transition_row[['delay']], N, N_developing)
  pred2 <- get_pred(time, transition_row[['pred2']], transition_row[['delay']], N, N_developing)
  
  do.call(f, as.list(c(list(pred1, pred2), params)))
}

# removing pipes
get_transition_val2 <- function(time, transition_row, N, N_developing, parameters = tick_params) {
  
  f <- get(transition_row[['transition_fun']])
  
  params <- filter(parameters, 
                   str_detect(transition_row[['from']], from), 
                   str_detect(transition_row[['to']], to))$param_value

  names(params) <- filter(parameters, 
                   str_detect(transition_row[['from']], from), 
                   str_detect(transition_row[['to']], to))$param_name
  
  params <- tapply(unname(params), rep(names(params), lengths(params)), FUN = c)
  
  pred1 <- get_pred(time, transition_row[['pred1']], transition_row[['delay']], N, N_developing)
  pred2 <- get_pred(time, transition_row[['pred2']], transition_row[['delay']], N, N_developing)
  
  do.call(f, as.list(c(list(pred1, pred2), params)))
}

# removing redundant as.list 
get_transition_val3 <- function(time, transition_row, N, N_developing, parameters = tick_params) {
  
  f <- get(transition_row[['transition_fun']])
  
  params <- filter(parameters, 
                   str_detect(transition_row[['from']], from), 
                   str_detect(transition_row[['to']], to))$param_value

  names(params) <- filter(parameters, 
                   str_detect(transition_row[['from']], from), 
                   str_detect(transition_row[['to']], to))$param_name
  
  params <- tapply(unname(params), rep(names(params), lengths(params)), FUN = c)
  
  pred1 <- get_pred(time, transition_row[['pred1']], transition_row[['delay']], N, N_developing)
  pred2 <- get_pred(time, transition_row[['pred2']], transition_row[['delay']], N, N_developing)
  
  do.call(f, c(list(pred1, pred2), params))
}

# split instead of tapply
get_transition_val4 <- function(time, transition_row, N, N_developing, parameters = tick_params) {
  
  f <- get(transition_row[['transition_fun']])
  
  params <- filter(parameters, 
                   str_detect(transition_row[['from']], from), 
                   str_detect(transition_row[['to']], to))$param_value

  names(params) <- filter(parameters, 
                   str_detect(transition_row[['from']], from), 
                   str_detect(transition_row[['to']], to))$param_name
  
  params <- split(unname(params), names(params))
  
  pred1 <- get_pred(time, transition_row[['pred1']], transition_row[['delay']], N, N_developing)
  pred2 <- get_pred(time, transition_row[['pred2']], transition_row[['delay']], N, N_developing)
  
  do.call(f, c(list(pred1, pred2), params))
}

# filter once, tapply
get_transition_val5 <- function(time, transition_row, N, N_developing, parameters = tick_params) {
  
  f <- get(transition_row[['transition_fun']])
  
  params_tbl <- filter(parameters, 
                   str_detect(transition_row[['from']], from), 
                   str_detect(transition_row[['to']], to))
  
  params <- params_tbl$param_value
  names(params) <- params_tbl$param_name

  params <- tapply(unname(params), rep(names(params), lengths(params)), FUN = c)
  
  pred1 <- get_pred(time, transition_row[['pred1']], transition_row[['delay']], N, N_developing)
  pred2 <- get_pred(time, transition_row[['pred2']], transition_row[['delay']], N, N_developing)
  
  do.call(f, c(list(pred1, pred2), params))
}

# filter once, split
get_transition_val6 <- function(time, transition_row, N, N_developing, parameters = tick_params) {
  
  f <- get(transition_row[['transition_fun']])
  
  params_tbl <- filter(parameters, 
                   str_detect(transition_row[['from']], from), 
                   str_detect(transition_row[['to']], to))
  
  params <- params_tbl$param_value
  names(params) <- params_tbl$param_name

  params <- split(unname(params), names(params))
  
  pred1 <- get_pred(time, transition_row[['pred1']], transition_row[['delay']], N, N_developing)
  pred2 <- get_pred(time, transition_row[['pred2']], transition_row[['delay']], N, N_developing)
  
  do.call(f, c(list(pred1, pred2), params))
}

# [] instead of filter
get_transition_val7 <- function(time, transition_row, N, N_developing, parameters = tick_params) {
  
  f <- get(transition_row[['transition_fun']])
  
  params_tbl <- parameters[intersect(str_which(transition_row[['from']], parameters$from),
                           str_which(transition_row[['to']], parameters$to)), ]
  
  params <- params_tbl$param_value
  names(params) <- params_tbl$param_name

  params <- split(unname(params), names(params))
  
  pred1 <- get_pred(time, transition_row[['pred1']], transition_row[['delay']], N, N_developing)
  pred2 <- get_pred(time, transition_row[['pred2']], transition_row[['delay']], N, N_developing)
  
  do.call(f, c(list(pred1, pred2), params))
}

# call str_which once
get_transition_val8 <- function(time, transition_row, N, N_developing, parameters = tick_params) {
  
  f <- get(transition_row[['transition_fun']])
  
  params_tbl <- parameters[str_which(paste0(transition_row[['from']], transition_row[['to']]),
                                     paste0(parameters$from, parameters$to)), ]
  
  params <- params_tbl$param_value
  names(params) <- params_tbl$param_name

  params <- split(unname(params), names(params))
  
  pred1 <- get_pred(time, transition_row[['pred1']], transition_row[['delay']], N, N_developing)
  pred2 <- get_pred(time, transition_row[['pred2']], transition_row[['delay']], N, N_developing)
  
  do.call(f, c(list(pred1, pred2), params))
}

# paste outside str_which 
get_transition_val9 <- function(time, transition_row, N, N_developing, parameters = tick_params) {
  
  f <- get(transition_row[['transition_fun']])
  
  string <- paste0(transition_row[['from']], transition_row[['to']])
  patterns <- paste0(parameters$from, parameters$to)
  
  params_tbl <- parameters[str_which(string, patterns), ]
  
  params <- params_tbl$param_value
  names(params) <- params_tbl$param_name

  params <- split(unname(params), names(params))
  
  pred1 <- get_pred(time, transition_row[['pred1']], transition_row[['delay']], N, N_developing)
  pred2 <- get_pred(time, transition_row[['pred2']], transition_row[['delay']], N, N_developing)
  
  do.call(f, c(list(pred1, pred2), params))
}

# different naming strategy
get_transition_val10 <- function(time, transition_row, N, N_developing, parameters = tick_params) {
  
  f <- get(transition_row[['transition_fun']])
  
  string <- paste0(transition_row[['from']], transition_row[['to']])
  patterns <- paste0(parameters$from, parameters$to)
  
  params_tbl <- parameters[str_which(string, patterns), ]
  
  params <- structure(params_tbl$param_value, names = params_tbl$param_name)
  
  params <- split(unname(params), names(params))
  
  pred1 <- get_pred(time, transition_row[['pred1']], transition_row[['delay']], N, N_developing)
  pred2 <- get_pred(time, transition_row[['pred2']], transition_row[['delay']], N, N_developing)
  
  do.call(f, c(list(pred1, pred2), params))
}


bnch <- mark(get_transition_val(time, transition_row, N, N_developing),
             get_transition_val2(time, transition_row, N, N_developing),
             get_transition_val3(time, transition_row, N, N_developing),
             get_transition_val4(time, transition_row, N, N_developing),
             get_transition_val5(time, transition_row, N, N_developing),
             get_transition_val6(time, transition_row, N, N_developing),
             get_transition_val7(time, transition_row, N, N_developing),
             get_transition_val8(time, transition_row, N, N_developing),
             get_transition_val9(time, transition_row, N, N_developing),
             get_transition_val10(time, transition_row, N, N_developing),
             iterations = 1000)
bnch

```

### takeaway
Speed of the `get_transition_val` versions 2, 3, and 4 are comparable, 2 seems to use a bit more memory. 5 and 6 are even faster - they call `filter` only once, and according to profiling `filter` is currently one of the major bottlenecks in general in the model. We'll use 6 which I think is slightly more readable.

Update: subsetting with [] rather than filter, and using str_which once rather than str_detect twice improve runtime significantly, nearly cutting it in half again. 8-10 are all pretty interchangable, we'll use 9.


## update_delay_arr 
```{r update_delay_arr}

library(tidyverse)
library(bench)
source('../core_functions.R')
source('../user_defined_functions.R')

max_delay <- 300
steps <- 500

tick_params <- read_csv('../inputs/tick_parameters.csv') %>% 
  arrange(host_spp) 
tick_transitions <- read_csv('../inputs/tick_transitions.csv')
life_stages <- tick_transitions %>% pull(from) %>% unique()

weather <- tibble(tmean = seq(from = 15, to = 15, length.out = steps), j_day = seq(from = 1, to = steps))
host_comm <- tibble(
  j_day = rep(1:steps, each=3), 
  host_spp = rep(c('mouse', 'squirrel', 'deer'), steps), 
  host_den = rep(c(100, 8, 8), steps)) %>%
  # host_den = runif(steps * 3, .75, 1.25) * rep(c(40, 8, 0.25), steps)) %>% 
  arrange(j_day, host_spp)

n_host_spp <- host_comm %>% pull(host_spp) %>% unique() %>% length()
time <- 1
N <- matrix(nrow = length(life_stages), ncol = steps, data = 0)
N[,1] <- 10 
rownames(N) <- life_stages
N_developing <- matrix(nrow = length(life_stages), ncol = steps, data = 0)
rownames(N) <- life_stages

delay_arr <- array(dim = c(length(life_stages), length(life_stages), steps + max_delay),
                   dimnames = list(life_stages, life_stages, NULL),
                   data = 0)

update_delay_arr <- function(time, delay_arr, N, N_developing) {
  
  # select all delay transition functions, including mortality
  transitions <- tick_transitions %>% filter(delay == 1)

  # loop through these transitions by from_stage 
  for (from_stage in transitions %>% pull(from) %>% unique()) {
    
    # for a given delay transition, every "from" stage has a unique "to" stage
    trans <- transitions %>% filter(from == from_stage, to %in% life_stages)
    to_stage <- trans[['to']]
    
    # daily probability of transitioning to the next stage
    val <- get_transition_val(time, trans, N, N_developing)
    
    # daily or per capita mortality during the delayed transition
    # each "from" stage has either 1 or 0 corresponding mortality transitions
    mort_tibble <- transitions %>% filter(from == from_stage, !(to %in% life_stages))
    if(nrow(mort_tibble) == 1) {
      mort <- get_transition_val(time, mort_tibble[1,], N, N_developing)    
    } else if (nrow(mort_tibble) == 0) {
      mort <- 0 
    } else {
      stop(nrow(mort_tibble), ' mortality transitions found from a single stage, should be 1 or 0')
    }
    
    # Constant functions (for a fixed delay transition) return a single value
    # We increase the length so that we can do a cumsum over the vector
    # We add 1 for consistency with output vector length from non-constant fxns,
    # which is determined by time:(time + max_delay) in get_pred()
    if (length(val) == 1) val <- rep(val, max_delay + 1)
    
    days <- cumsum(val) >= 1
    
    if (any(days)) {
      
      # delay duration is the number of days until the first day when the sum
      # of the daily probabilities >= 1
      days_to_next <- min(which(days))
      
      if (length(mort) > 1) {
        # Non-constant mortality
        # We might ultimately want density_fun() to return a vector of length > 1,
        # where the value for each day is calculated based on that day's feeding tick population
        # But currently, all mortality transitions are either constant_fun() or density_fun(), 
        # both of which return a vector of length 1, so we shouldn't ever get to this case.
        print('non-constant mortality')
        
        # in this case, mort is a vector of length max_delay?
        # we susbet it for the duration of the delay
        # then elementwise subtract (1 - each element) to get vector of daily survival rate,
        # and take product to get the overall survival rate throughout the delay
        surv_to_next <- prod(1 - mort[1:days_to_next])
        
      } else if (nrow(mort_tibble) == 1 && mort_tibble['to'] == 'per_capita_m') {
        # Apply per capita mortality once during transition, rather than every day
        surv_to_next <- 1 - mort
        
      } else {
        # Constant mortality
        surv_to_next <- (1 - mort) ^ days_to_next
      }
      
      # number of ticks emerging from from_stage to to_stage at time + days_to_next is the number of ticks 
      # that were already going to emerge then plus the current number of ticks in the from_stage * survival
      delay_arr[to_stage, from_stage, time + days_to_next] <- 
        delay_arr[to_stage, from_stage, time + days_to_next] +
        N[from_stage, time] * surv_to_next
    }
  }
  return(delay_arr)
}

update_delay_arr2 <- function(time, delay_arr, N, N_developing) {
  
  # select all delay transition functions, including mortality
  transitions <- filter(tick_transitions, delay == 1)

  # loop through these transitions by from_stage 
  from_stages <- unique(pull(transitions, from))
  for (from_stage in from_stages) {
    
    # for a given delay transition, every "from" stage has a unique "to" stage
    trans <- filter(transitions,
                    from == from_stage,
                    to %in% life_stages)
    to_stage <- trans[['to']]
    
    # daily probability of transitioning to the next stage
    val <- get_transition_val(time, trans, N, N_developing)
    
    # daily or per capita mortality during the delayed transition
    # each "from" stage has either 1 or 0 corresponding mortality transitions
    mort_tibble <- filter(transitions, 
                          from == from_stage, 
                          !(to %in% life_stages))
    if(nrow(mort_tibble) == 1) {
      mort <- get_transition_val(time, mort_tibble[1,], N, N_developing)    
    } else if (nrow(mort_tibble) == 0) {
      mort <- 0 
    } else {
      stop(nrow(mort_tibble), ' mortality transitions found from a single stage, should be 1 or 0')
    }
    
    # Constant functions (for a fixed delay transition) return a single value
    # We increase the length so that we can do a cumsum over the vector
    # We add 1 for consistency with output vector length from non-constant fxns,
    # which is determined by time:(time + max_delay) in get_pred()
    if (length(val) == 1) val <- rep(val, max_delay + 1)
    
    days <- cumsum(val) >= 1
    
    if (any(days)) {
      
      # delay duration is the number of days until the first day when the sum
      # of the daily probabilities >= 1
      days_to_next <- min(which(days))
      
      if (length(mort) > 1) {
        # Non-constant mortality
        # We might ultimately want density_fun() to return a vector of length > 1,
        # where the value for each day is calculated based on that day's feeding tick population
        # But currently, all mortality transitions are either constant_fun() or density_fun(), 
        # both of which return a vector of length 1, so we shouldn't ever get to this case.
        print('non-constant mortality')
        
        # in this case, mort is a vector of length max_delay?
        # we susbet it for the duration of the delay
        # then elementwise subtract (1 - each element) to get vector of daily survival rate,
        # and take product to get the overall survival rate throughout the delay
        surv_to_next <- prod(1 - mort[1:days_to_next])
        
      } else if (nrow(mort_tibble) == 1 && mort_tibble['to'] == 'per_capita_m') {
        # Apply per capita mortality once during transition, rather than every day
        surv_to_next <- 1 - mort
        
      } else {
        # Constant mortality
        surv_to_next <- (1 - mort) ^ days_to_next
      }
      
      # number of ticks emerging from from_stage to to_stage at time + days_to_next is the number of ticks 
      # that were already going to emerge then plus the current number of ticks in the from_stage * survival
      delay_arr[to_stage, from_stage, time + days_to_next] <- 
        delay_arr[to_stage, from_stage, time + days_to_next] +
        N[from_stage, time] * surv_to_next
    }
  }
  return(delay_arr)
}


# use [ rather than filter for subsetting
update_delay_arr3 <- function(time, delay_arr, N, N_developing) {
  
  # select all delay transition functions, including mortality
  transitions <- tick_transitions[tick_transitions$delay == 1, ]

  # loop through these transitions by from_stage 
  from_stages <- unique(pull(transitions, from))
  for (from_stage in from_stages) {
    
    # for a given delay transition, every "from" stage has a unique "to" stage
    trans <- transitions[transitions$from == from_stage &
                           transitions$to %in% life_stages, ]
    
    to_stage <- trans[['to']]
    
    # daily probability of transitioning to the next stage
    val <- get_transition_val(time, trans, N, N_developing)
    
    # daily or per capita mortality during the delayed transition
    # each "from" stage has either 1 or 0 corresponding mortality transitions
    
    mort_tibble <- transitions[transitions$from == from_stage &
                                 !(transitions$to %in% life_stages), ]
    
    if(nrow(mort_tibble) == 1) {
      mort <- get_transition_val(time, mort_tibble[1,], N, N_developing)    
    } else if (nrow(mort_tibble) == 0) {
      mort <- 0 
    } else {
      stop(nrow(mort_tibble), ' mortality transitions found from a single stage, should be 1 or 0')
    }
    
    # Constant functions (for a fixed delay transition) return a single value
    # We increase the length so that we can do a cumsum over the vector
    # We add 1 for consistency with output vector length from non-constant fxns,
    # which is determined by time:(time + max_delay) in get_pred()
    if (length(val) == 1) val <- rep(val, max_delay + 1)
    
    days <- cumsum(val) >= 1
    
    if (any(days)) {
      
      # delay duration is the number of days until the first day when the sum
      # of the daily probabilities >= 1
      days_to_next <- min(which(days))
      
      if (length(mort) > 1) {
        # Non-constant mortality
        # We might ultimately want density_fun() to return a vector of length > 1,
        # where the value for each day is calculated based on that day's feeding tick population
        # But currently, all mortality transitions are either constant_fun() or density_fun(), 
        # both of which return a vector of length 1, so we shouldn't ever get to this case.
        print('non-constant mortality')
        
        # in this case, mort is a vector of length max_delay?
        # we susbet it for the duration of the delay
        # then elementwise subtract (1 - each element) to get vector of daily survival rate,
        # and take product to get the overall survival rate throughout the delay
        surv_to_next <- prod(1 - mort[1:days_to_next])
        
      } else if (nrow(mort_tibble) == 1 && mort_tibble['to'] == 'per_capita_m') {
        # Apply per capita mortality once during transition, rather than every day
        surv_to_next <- 1 - mort
        
      } else {
        # Constant mortality
        surv_to_next <- (1 - mort) ^ days_to_next
      }
      
      # number of ticks emerging from from_stage to to_stage at time + days_to_next is the number of ticks 
      # that were already going to emerge then plus the current number of ticks in the from_stage * survival
      delay_arr[to_stage, from_stage, time + days_to_next] <- 
        delay_arr[to_stage, from_stage, time + days_to_next] +
        N[from_stage, time] * surv_to_next
    }
  }
  return(delay_arr)
}



mark(update_delay_arr(time, delay_arr, N, N_developing),
     update_delay_arr2(time, delay_arr, N, N_developing),
     update_delay_arr3(time, delay_arr, N, N_developing),
     iterations = 200)

```

### takeaway
Removing the pipes in `update_delay_arr` has a minimal effect on performance, I suspect this is because the function is doing a large amount of work (vs something like `get_temp`), and the pipe is trivial in comparison. I see no other obvious opportunities to increase performance in `update_delay_arr`, so I'll stick with the original version.

## apply in run()
Based on profiling, it seems like the call to `apply` in the `run` function is slow. I'm going to isolate that and see if there's a faster alternative.

```{r apply}
life_stages <- c('e', 'l', 'n', 'a')
steps <- 500
max_delay <- 300

delay_arr <- array(dim = c(length(life_stages), length(life_stages), steps + max_delay),
                   dimnames = list(life_stages, life_stages, NULL),
                   data = runif(length(life_stages) * length(life_stages) * (steps + max_delay)))

f1 <- function(delay_arr) apply(delay_arr, 3, rowSums)

```

### takeaway 
I'm having trouble figuring out other ways to accomplish this summing functionality, let alone a faster alternative. Going to leave it as is for now. At this point, I suspect the low hanging fruit for optimization has been handled, and it may be increasingly tricky to speed things up significantly. My very rough assessment based on profiling is that run time has been cut in half at least. Model runtime for 500 steps with the Ogden inputs went from about 60 seconds before any benchmarking to about 24 seconds now.



## grab parameters once (rather than every call to get_transition_vals)
``` {r grab parameters once}
# return list of parameters for a given transition_row
get_params <- function(from, to, parameters = tick_params) {
  
  string <- paste0(from, to)
  patterns <- paste0(parameters$from, parameters$to)
  
  params_tbl <- parameters[str_which(string, patterns), ]
  
  params <- params_tbl$param_value
  names(params) <- params_tbl$param_name
  params <- split(unname(params), names(params))
  
  params
}

# return a new tick_transitions tibble with a column, params_list
# that is a named list of the parameters for each transition
add_params_list <- function(tick_transitions, parameters = tick_params) {

  # TODO should be a vectorized approach
  params_list <- list()

    for (i in 1:nrow(tick_transitions)) {
    p <- get_params(tick_transitions[[i,'from']], tick_transitions[[i, 'to']])
    params_list[[i]] <- p
  }
  
  mutate(tick_transitions, params_list = params_list)
}

tick_transitions2 <- add_params_list(tick_transitions)

# copied from above, just to ensure using correct version
get_transition_val10 <- function(time, transition_row, N, N_developing, parameters = tick_params) {
  
  f <- get(transition_row[['transition_fun']])
  
  string <- paste0(transition_row[['from']], transition_row[['to']])
  patterns <- paste0(parameters$from, parameters$to)
  
  params_tbl <- parameters[str_which(string, patterns), ]
  
  params <- structure(params_tbl$param_value, names = params_tbl$param_name)
  
  params <- split(unname(params), names(params))
  
  pred1 <- get_pred(time, transition_row[['pred1']], transition_row[['delay']], N, N_developing)
  pred2 <- get_pred(time, transition_row[['pred2']], transition_row[['delay']], N, N_developing)
  
  do.call(f, c(list(pred1, pred2), params))
}

get_transition_val11 <- function(time, transition_row_with_parameters, N, N_developing) {
  
  f <- get(transition_row_with_parameters[['transition_fun']])
  
  params <- transition_row_with_parameters[['params_list']]
  
  pred1 <- get_pred(time, transition_row_with_parameters[['pred1']], 
                          transition_row_with_parameters[['delay']], N, N_developing)
  pred2 <- get_pred(time, transition_row_with_parameters[['pred2']], 
                          transition_row_with_parameters[['delay']], N, N_developing)
  
  do.call(f, c(list(pred1, pred2), params[[1]]))
}

mark(get_transition_val10(1, tick_transitions[1,], N, N_developing),
     get_transition_val11(1, tick_transitions2[1,], N, N_developing))

```

### Takeaways 
This sped things up a lot for short model runs, e.g. runtime using Ogden inputs for 300 steps decreased by about 40% after this change. This is because filtering the parameter tibble using the [ operator was taking a lot of time. Since the parameters don't change during a model run, we can extract this functionality and do this just once, and add the parameters as a list to each transition row. 

However, the increase in speed is fairly minor, about 15% when the model is run using the Ogden inputs for 3500 steps. See `before/after_separate_single_parameter_grab_optimization.Rprofvis` for details. It seems like as the model runtime grows, the `apply()` call in the run function becomes increasingly dominant/slow. This suggests that performing operations (`rowSums()` and any other processing `apply()` does) on bigger matrices is slower... so figuring out a more efficient alternative to `apply()` would be particularly important for speeding up the runtime of the model for longer time periods.



## apply in run() attempt 2
The main goal now is to better understand the transformation we are doing to the delay_arr in the run funciton, and how they can be optimized.

```{r apply attempt 2}

library(bench)
library(tidyverse)

life_stages <- c('l', 'a')
steps <- 2
max_delay <- 1

# dimensions are to_stage, from_stage, time
delay_arr <- array(dim = c(length(life_stages), length(life_stages), steps + max_delay),
                   dimnames = list(str_c("from_", life_stages), str_c("to_", life_stages), NULL),
                   # data = runif(length(life_stages) * length(life_stages) * (steps + max_delay)))
                   data = (1 : (length(life_stages) * length(life_stages) * (steps + max_delay))))


old_delay_arr <- aperm(delay_arr, c(2,1,3))


# sum across from_stage dimension to get a matrix with dims (to_stage, time)
f1 <- function(old_delay_arr) apply(old_delay_arr, 3, rowSums)
f2 <- function(old_delay_arr) apply(old_delay_arr, c(1,3), sum)
f3 <- function(delay_arr) colSums(delay_arr)

mark(f1(old_delay_arr),
     f2(old_delay_arr),
     f3(delay_arr),
     iterations = 100000)


```

### takeaway
Switching the from and to dimensions of the delay_arr allows using colSums for a much faster approach to reducing the 3d array to a 2d matrix. 

After implementing this change (switching the array dimensions) in the code (`core_functions.R`), I ran the model with the Ogden inputs for 3500 steps. I double checked that the model output did not change.  The biggest takeaway is that runtime dropped by about 70%, from about 230 to 73 seconds. The profiling results are in `after_reshaping_delay_arr.Rprofvis`. Compare this to `after_single_parameter_grab_optimization.Rprofvis` to see more details on the change in performance. 



